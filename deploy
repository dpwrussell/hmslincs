#!/bin/sh
# -*- mode: shell-script -*-

STARTED=$(date '+%FT%T%z (%A)')
ARGS="$@"
DEBUG=${DEBUG:-false}
PROG=$(basename $0)
REALPATH=${REALPATH:-realpath}
BASEDIR=${BASEDIR:-"$(dirname $($REALPATH $0))"}
SUPPORTDIR=${SUPPORTDIR:-"$(dirname $(dirname $BASEDIR))/support"}
VENV=${VENV:-"$SUPPORTDIR/virtualenv"}
REQUIREMENTS=${REQUIREMENTS:-"$BASEDIR/requirements.txt"}

PROGDIR=${PROGDIR:-"$BASEDIR/.$PROG"}
LOGFILE=${LOGFILE:-"$PROGDIR/log"}
LOCKFILE=${LOCKFILE:-"$PROGDIR/lock"}
ADMINDIR=${ADMINDIR:-"$($REALPATH $SUPPORTDIR/..)/docroot/admin"}

PRODSITE=prod
DEVSITE=dev

PRODBRANCH=master
DEVBRANCH=dev
# PRODBRANCH=test-ignore
# DEVBRANCH=test-ignore

URLTEMPLATE='http://%slincs.hms.harvard.edu/cgi-bin/cleanup.cgi'

REMOTE=${REMOTE:-hmslincs}
FULL=false
IMAGES=true

function cleanup {
  _debug -n "removing $LOCKFILE ..."
  rm -f $LOCKFILE
  _debug "done"
}

function warn {
  echo "$PROG: $@" >&2
}

function error {
  warn "$@"
  exit 1
}

function _debug {
  if $DEBUG; then echo "$@"; fi
}

function __usage {
    cat <<EOF
$PROG [-m|-f] [-d] [SITE [BRANCH]]

$PROG -h

  -h -- print this help message and exit
  -m -- minimal update
  -f -- do full update (rebuild db, remake and move images, etc.)
  -d -- debug mode

SITE should be either $PRODSITE or $DEVSITE.  BRANCH should be a suitable
branch from $REMOTE.

Default actions: git-pull, make and move files, kill fast cgi.
EOF
    exit $1
}

function main {
  OPTIND=1
  while getopts ":hmfd" opt "$@"
  do
    case "$opt" in
      h) __usage 0;;
      m) FULL=false
         IMAGES=false;;
      f) FULL=true
         IMAGES=true;;
      d) DEBUG=true
         LOGFILE=$(tty);;
      ?) echo "$0: illegal option -- $OPTARG" >&2
         __usage 1;;
    esac
  done

  shift $(( OPTIND - 1 ))

  cd "$BASEDIR" || error "can't cd to $BASEDIR"

  SITE="$1"
  BRANCH="$2"

  if [[ -z $SITE ]]; then
    case "$BASEDIR" in
      /www/lincs.*) SITE="$PRODSITE" ;;
                 *) SITE="$DEVSITE" ;;
    esac
  fi

  if [[ -z $BRANCH ]]; then
    if [[ $SITE = $PRODSITE ]]; then
      BRANCH="$PRODBRANCH"
    else
      BRANCH="$DEVBRANCH"
    fi
  fi

  if [[ $SITE = $PRODSITE ]]; then
    KILLFCGI=$(printf "$URLTEMPLATE" "")
  elif [[ $SITE = $DEVSITE ]]; then
    KILLFCGI=$(printf "$URLTEMPLATE" dev.)
  else
    KILLFCGI=
    echo "$SITE is not a supported site: will not run cleanup.cgi"
  fi

  if $DEBUG; then
    cat <<EOF
params:
SITE: $SITE
REMOTE: $REMOTE
BRANCH: $BRANCH
KILLFCGI: $KILLFCGI
EOF

  fi

  deploy || error "failed with status $?"

  return 0
}

function gitpull {
  _debug -n "pulling branch $BRANCH from $REMOTE... "
  git checkout $BRANCH >>"$LOGFILE" 2>&1 || error "git-checkout failed: $?"
  git pull --ff-only $REMOTE $BRANCH: >>"$LOGFILE" 2>&1 || error "git-pull failed: $?"
  _debug 'done'
  return 0
}

function invenv {
  local pyex="$VENV/bin/python"
  if [[ -z $VENV || ! -x $pyex ]]; then
     error "VENV ($VENV) does not point to a valid virtualenv directory"
  fi

  [[ $VIRTUAL_ENV == $VENV && $(which python) == $pyex ]] && \
    python -c 'import sys; sys.real_prefix' 2>/dev/null
}

function maybe_activate_virtualenv {
  if invenv; then return; fi

  source "$VENV/bin/activate" || error "failed to activate virtualenv: $?"

  if invenv; then return; fi

  error 'failed to activate virtualenv (reason unknown)'
}

function runpip {
  if [[ ! -e $REQUIREMENTS ]]; then
    error "cannot find requirements file ($REQUIREMENTS)"
  fi

  maybe_activate_virtualenv

  sed 's/^\s*//; s/\s*#.*//' $REQUIREMENTS | \
    while IFS= read -r line; do
      if [[ -z $line ]]; then continue; fi
      pip install -v $line || error "pip install $line failed: $?"
    done
  _debug 'done'
  return 0
}

function builddb {
  if $FULL; then
    _debug -n 'building db... '
    $BASEDIR/re_run.sh $SITE >>"$LOGFILE" 2>&1 || error "re_run.sh failed: $?"
    _debug 'done'
  fi
}

function makeimg {
  if $IMAGES; then
    _debug -n 'making images... '
    cd "$BASEDIR" || return 1
    src/do_scatterplots.sh >>"$LOGFILE" 2>&1 || \
        error "src/do_scatterplots.sh failed: $?"
    PYTHONPATH="$BASEDIR"/django DJANGO_SETTINGS_MODULE=hmslincs_server.settings \
	python src/do_pathway.py >>"$LOGFILE" 2>&1 || \
        error "src/do_pathway.py failed: $?"
    _debug 'done'
  fi
}

function moveimg {
  if $IMAGES; then
    _debug -n 'moving images... '
    cd "$BASEDIR" || return 1
    DEBUG=$DEBUG ./find_and_move_restricted_images.sh >>"$LOGFILE" 2>&1 || \
        error "find_and_move_restricted_images.sh failed: $?"
    _debug 'done'
  fi
}

function collectstatic {
  _debug -n 'collecting statics... '
  cd "$BASEDIR" || return 1
  mkdir -p $SUPPORTDIR/images || return 1
  python django/manage.py collectstatic --noinput >>"$LOGFILE" 2>&1 || \
      error "manage.py collectstatic failed: $?"
  _debug 'done'
}

function killfcgi {
  [[ -z $KILLFCGI ]] && return 0
  _debug -n 'running cleanup.cgi... '
  curl -sf "$KILLFCGI" >> "$LOGFILE" || error '"'"curl -f $KILLFCGI"'" failed'
  _debug 'done'
}

function _mkdirp {
  mkdir -p $1 || error "could not make $1: $?"
  chmod 775 $1 || error "could not chmod $1: $?"
}

function deploy {

  _mkdirp $PROGDIR
  _mkdirp $ADMINDIR

  if [[ -e $LOCKFILE ]]; then
    error "$LOCKFILE exists:

$(cat $LOCKFILE)

exiting..."
  else
    $DEBUG || trap cleanup EXIT
  fi

  local ssh_client=${SSH_CLIENT/ *}

  printf "$PROG $ARGS\t$USER:$UID:$ssh_client\t$(hostname)\t$$\t$STARTED\n" \
    >"$LOCKFILE"

  local adminfile="$ADMINDIR/$PROG.txt"
  local adminfilebak="$adminfile.bak"
  mv "$adminfile" "$adminfilebak"
  cp -a $LOCKFILE $adminfile
  chmod 664 $adminfile
  cat "$adminfilebak" >> "$adminfile"

  if [[ -s $LOGFILE ]]; then
    cat <<EOF >>"$LOGFILE"

===========================================================================
EOF
  fi

  cat <<EOF >>"$LOGFILE"
$STARTED
deployed by $USER ($UID) connected from $ssh_client


EOF

  maybe_activate_virtualenv
  gitpull && runpip && builddb && makeimg && moveimg && collectstatic && killfcgi
  echo done
}

main "$@"
